import { Injectable, Logger, Inject, forwardRef } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, IsNull } from 'typeorm';
import { Cron } from '@nestjs/schedule';
import { Photo } from './photo.entity';
import { GuessService } from '../guess/guess.service';

@Injectable()
export class PhotoService {
  private readonly logger = new Logger(PhotoService.name);

  constructor(
    @InjectRepository(Photo)
    private readonly repo: Repository<Photo>,
    @Inject(forwardRef(() => GuessService))
    private readonly guessService: GuessService,
  ) {}

  @Cron('0 * * * *')  // Toutes les heures √† minute 0
  async generateDailyPhoto() {
    const date = new Date().toISOString().slice(0, 10);
    this.logger.log(`üîÑ Tentative de g√©n√©ration de photo pour ${date}`);
    
    // V√©rifier si une photo est d√©j√† assign√©e pour aujourd'hui
    const existingPhoto = await this.repo.findOneBy({ date });
    if (existingPhoto) {
      // Mettre la date d'hier sur l'ancienne photo
      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);
      await this.repo.update(existingPhoto.id, { date: yesterday.toISOString().slice(0, 10) });
      this.logger.log(`üìÖ Photo existante d√©plac√©e √† hier`);
    }
    
    // Supprimer les guesses pour la date du jour
    await this.guessService.deleteGuessesForDate(date);
    this.logger.log(`üßπ Guesses supprim√©s pour ${date}`);
    
    // S√©lectionner une photo existante non utilis√©e
    const unusedPhoto = await this.repo.findOne({
      where: { date: IsNull() },
      order: { id: 'ASC' }
    });

    if (!unusedPhoto) {
      this.logger.error('‚ùå Aucune photo non utilis√©e disponible');
      return;
    }

    // Mettre √† jour la photo avec la date
    await this.repo.update(unusedPhoto.id, { date });
    this.logger.log(`‚úÖ Nouvelle photo assign√©e pour ${date}`);
  }

  async getToday(): Promise<Photo> {
    const date = new Date().toISOString().slice(0,10);
    const photo = await this.repo.findOneBy({ date });
    if (!photo) throw new Error(`No photo found for date ${date}`);
    return photo;
  }

  async addPhoto(imageUrl: string, solution: string): Promise<Photo> {
    return this.repo.save({ imageUrl, solution });
  }

  async listUnusedPhotos(): Promise<Photo[]> {
    return this.repo.find({
      where: { date: IsNull() },
      order: { id: 'ASC' }
    });
  }

  async listAllPhotos(): Promise<Photo[]> {
    return this.repo.find({
      order: { id: 'ASC' }
    });
  }

  async deletePhoto(id: number): Promise<void> {
    const photo = await this.repo.findOneBy({ id });
    if (!photo) return;

    // Si c'est la photo du jour, supprimer les guesses et g√©n√©rer une nouvelle photo
    if (photo.date === new Date().toISOString().slice(0, 10)) {
      await this.guessService.deleteGuessesForDate(photo.date);
      
      // Mettre la date d'hier sur l'ancienne photo
      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);
      await this.repo.update(id, { date: yesterday.toISOString().slice(0, 10) });
      
      // G√©n√©rer une nouvelle photo
      await this.generateDailyPhoto();
    } else {
      await this.repo.delete(id);
    }
  }

  async resetAllPhotos(): Promise<void> {
    const today = new Date().toISOString().slice(0, 10);
    
    // Supprimer les guesses du jour
    await this.guessService.deleteGuessesForDate(today);
    
    // Supprimer toutes les dates
    await this.repo.query('UPDATE photo SET date = NULL');
    
    // G√©n√©rer une nouvelle photo du jour
    await this.generateDailyPhoto();
  }
}
